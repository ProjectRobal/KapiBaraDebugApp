// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rc_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rc_5fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_rc_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_rc_5fservice_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rc_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_rc_5fservice_2eproto;
class AudioChunk;
struct AudioChunkDefaultTypeInternal;
extern AudioChunkDefaultTypeInternal _AudioChunk_default_instance_;
class Command;
struct CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class DistanceSensor;
struct DistanceSensorDefaultTypeInternal;
extern DistanceSensorDefaultTypeInternal _DistanceSensor_default_instance_;
class Gyroscope;
struct GyroscopeDefaultTypeInternal;
extern GyroscopeDefaultTypeInternal _Gyroscope_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Motor;
struct MotorDefaultTypeInternal;
extern MotorDefaultTypeInternal _Motor_default_instance_;
class Servo;
struct ServoDefaultTypeInternal;
extern ServoDefaultTypeInternal _Servo_default_instance_;
class _None;
struct _NoneDefaultTypeInternal;
extern _NoneDefaultTypeInternal __None_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template <>
::AudioChunk* Arena::CreateMaybeMessage<::AudioChunk>(Arena*);
template <>
::Command* Arena::CreateMaybeMessage<::Command>(Arena*);
template <>
::DistanceSensor* Arena::CreateMaybeMessage<::DistanceSensor>(Arena*);
template <>
::Gyroscope* Arena::CreateMaybeMessage<::Gyroscope>(Arena*);
template <>
::Message* Arena::CreateMaybeMessage<::Message>(Arena*);
template <>
::Motor* Arena::CreateMaybeMessage<::Motor>(Arena*);
template <>
::Servo* Arena::CreateMaybeMessage<::Servo>(Arena*);
template <>
::_None* Arena::CreateMaybeMessage<::_None>(Arena*);
PROTOBUF_NAMESPACE_CLOSE


// ===================================================================


// -------------------------------------------------------------------

class _None final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:_None) */ {
 public:
  inline _None() : _None(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR _None(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  _None(const _None& from);
  _None(_None&& from) noexcept
    : _None() {
    *this = ::std::move(from);
  }

  inline _None& operator=(const _None& from) {
    CopyFrom(from);
    return *this;
  }
  inline _None& operator=(_None&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const _None& default_instance() {
    return *internal_default_instance();
  }
  static inline const _None* internal_default_instance() {
    return reinterpret_cast<const _None*>(
               &__None_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(_None& a, _None& b) {
    a.Swap(&b);
  }
  inline void Swap(_None* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(_None* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  _None* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<_None>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const _None& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const _None& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "_None";
  }
  protected:
  explicit _None(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:_None)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rc_5fservice_2eproto;
};// -------------------------------------------------------------------

class Motor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Motor) */ {
 public:
  inline Motor() : Motor(nullptr) {}
  ~Motor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Motor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Motor(const Motor& from);
  Motor(Motor&& from) noexcept
    : Motor() {
    *this = ::std::move(from);
  }

  inline Motor& operator=(const Motor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Motor& operator=(Motor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Motor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Motor* internal_default_instance() {
    return reinterpret_cast<const Motor*>(
               &_Motor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Motor& a, Motor& b) {
    a.Swap(&b);
  }
  inline void Swap(Motor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Motor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Motor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Motor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Motor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Motor& from) {
    Motor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Motor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Motor";
  }
  protected:
  explicit Motor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // uint32 direction = 1;
  void clear_direction() ;
  ::uint32_t direction() const;
  void set_direction(::uint32_t value);

  private:
  ::uint32_t _internal_direction() const;
  void _internal_set_direction(::uint32_t value);

  public:
  // uint32 speed = 2;
  void clear_speed() ;
  ::uint32_t speed() const;
  void set_speed(::uint32_t value);

  private:
  ::uint32_t _internal_speed() const;
  void _internal_set_speed(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Motor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t direction_;
    ::uint32_t speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rc_5fservice_2eproto;
};// -------------------------------------------------------------------

class DistanceSensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DistanceSensor) */ {
 public:
  inline DistanceSensor() : DistanceSensor(nullptr) {}
  ~DistanceSensor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DistanceSensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DistanceSensor(const DistanceSensor& from);
  DistanceSensor(DistanceSensor&& from) noexcept
    : DistanceSensor() {
    *this = ::std::move(from);
  }

  inline DistanceSensor& operator=(const DistanceSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistanceSensor& operator=(DistanceSensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DistanceSensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const DistanceSensor* internal_default_instance() {
    return reinterpret_cast<const DistanceSensor*>(
               &_DistanceSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DistanceSensor& a, DistanceSensor& b) {
    a.Swap(&b);
  }
  inline void Swap(DistanceSensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistanceSensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DistanceSensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DistanceSensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DistanceSensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DistanceSensor& from) {
    DistanceSensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistanceSensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DistanceSensor";
  }
  protected:
  explicit DistanceSensor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceFieldNumber = 1,
  };
  // double distance = 1;
  void clear_distance() ;
  double distance() const;
  void set_distance(double value);

  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);

  public:
  // @@protoc_insertion_point(class_scope:DistanceSensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double distance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rc_5fservice_2eproto;
};// -------------------------------------------------------------------

class Gyroscope final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Gyroscope) */ {
 public:
  inline Gyroscope() : Gyroscope(nullptr) {}
  ~Gyroscope() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Gyroscope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gyroscope(const Gyroscope& from);
  Gyroscope(Gyroscope&& from) noexcept
    : Gyroscope() {
    *this = ::std::move(from);
  }

  inline Gyroscope& operator=(const Gyroscope& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gyroscope& operator=(Gyroscope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gyroscope& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gyroscope* internal_default_instance() {
    return reinterpret_cast<const Gyroscope*>(
               &_Gyroscope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Gyroscope& a, Gyroscope& b) {
    a.Swap(&b);
  }
  inline void Swap(Gyroscope* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gyroscope* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gyroscope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gyroscope>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gyroscope& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Gyroscope& from) {
    Gyroscope::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gyroscope* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Gyroscope";
  }
  protected:
  explicit Gyroscope(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccelerationFieldNumber = 3,
    kGyroscopeFieldNumber = 6,
    kAccelRangeFieldNumber = 7,
    kGyroRangeFieldNumber = 8,
  };
  // repeated double acceleration = 3;
  int acceleration_size() const;
  private:
  int _internal_acceleration_size() const;

  public:
  void clear_acceleration() ;
  double acceleration(int index) const;
  void set_acceleration(int index, double value);
  void add_acceleration(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& acceleration() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* mutable_acceleration();

  private:
  double _internal_acceleration(int index) const;
  void _internal_add_acceleration(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& _internal_acceleration() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* _internal_mutable_acceleration();

  public:
  // repeated double gyroscope = 6;
  int gyroscope_size() const;
  private:
  int _internal_gyroscope_size() const;

  public:
  void clear_gyroscope() ;
  double gyroscope(int index) const;
  void set_gyroscope(int index, double value);
  void add_gyroscope(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& gyroscope() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* mutable_gyroscope();

  private:
  double _internal_gyroscope(int index) const;
  void _internal_add_gyroscope(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& _internal_gyroscope() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* _internal_mutable_gyroscope();

  public:
  // int32 accel_range = 7;
  void clear_accel_range() ;
  ::int32_t accel_range() const;
  void set_accel_range(::int32_t value);

  private:
  ::int32_t _internal_accel_range() const;
  void _internal_set_accel_range(::int32_t value);

  public:
  // int32 gyro_range = 8;
  void clear_gyro_range() ;
  ::int32_t gyro_range() const;
  void set_gyro_range(::int32_t value);

  private:
  ::int32_t _internal_gyro_range() const;
  void _internal_set_gyro_range(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Gyroscope)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<double> acceleration_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<double> gyroscope_;
    ::int32_t accel_range_;
    ::int32_t gyro_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rc_5fservice_2eproto;
};// -------------------------------------------------------------------

class Servo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Servo) */ {
 public:
  inline Servo() : Servo(nullptr) {}
  ~Servo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Servo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Servo(const Servo& from);
  Servo(Servo&& from) noexcept
    : Servo() {
    *this = ::std::move(from);
  }

  inline Servo& operator=(const Servo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Servo& operator=(Servo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Servo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Servo* internal_default_instance() {
    return reinterpret_cast<const Servo*>(
               &_Servo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Servo& a, Servo& b) {
    a.Swap(&b);
  }
  inline void Swap(Servo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Servo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Servo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Servo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Servo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Servo& from) {
    Servo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Servo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Servo";
  }
  protected:
  explicit Servo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
  };
  // uint32 angle = 1;
  void clear_angle() ;
  ::uint32_t angle() const;
  void set_angle(::uint32_t value);

  private:
  ::uint32_t _internal_angle() const;
  void _internal_set_angle(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Servo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint32_t angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rc_5fservice_2eproto;
};// -------------------------------------------------------------------

class AudioChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AudioChunk) */ {
 public:
  inline AudioChunk() : AudioChunk(nullptr) {}
  ~AudioChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioChunk(const AudioChunk& from);
  AudioChunk(AudioChunk&& from) noexcept
    : AudioChunk() {
    *this = ::std::move(from);
  }

  inline AudioChunk& operator=(const AudioChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioChunk& operator=(AudioChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioChunk* internal_default_instance() {
    return reinterpret_cast<const AudioChunk*>(
               &_AudioChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AudioChunk& a, AudioChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioChunk& from) {
    AudioChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "AudioChunk";
  }
  protected:
  explicit AudioChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 32000,
  };
  // repeated int32 data = 32000;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::int32_t data(int index) const;
  void set_data(int index, ::int32_t value);
  void add_data(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_data();

  private:
  ::int32_t _internal_data(int index) const;
  void _internal_add_data(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:AudioChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _data_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rc_5fservice_2eproto;
};// -------------------------------------------------------------------

class Command final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  ~Command() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Command(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Command& default_instance() {
    return *internal_default_instance();
  }
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Command& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Command& from) {
    Command::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMAFieldNumber = 1,
    kMBFieldNumber = 2,
    kEar1FieldNumber = 3,
    kEar2FieldNumber = 4,
  };
  // .Motor mA = 1;
  bool has_ma() const;
  void clear_ma() ;
  const ::Motor& ma() const;
  PROTOBUF_NODISCARD ::Motor* release_ma();
  ::Motor* mutable_ma();
  void set_allocated_ma(::Motor* ma);
  private:
  const ::Motor& _internal_ma() const;
  ::Motor* _internal_mutable_ma();
  public:
  void unsafe_arena_set_allocated_ma(
      ::Motor* ma);
  ::Motor* unsafe_arena_release_ma();
  // .Motor mB = 2;
  bool has_mb() const;
  void clear_mb() ;
  const ::Motor& mb() const;
  PROTOBUF_NODISCARD ::Motor* release_mb();
  ::Motor* mutable_mb();
  void set_allocated_mb(::Motor* mb);
  private:
  const ::Motor& _internal_mb() const;
  ::Motor* _internal_mutable_mb();
  public:
  void unsafe_arena_set_allocated_mb(
      ::Motor* mb);
  ::Motor* unsafe_arena_release_mb();
  // .Servo ear1 = 3;
  bool has_ear1() const;
  void clear_ear1() ;
  const ::Servo& ear1() const;
  PROTOBUF_NODISCARD ::Servo* release_ear1();
  ::Servo* mutable_ear1();
  void set_allocated_ear1(::Servo* ear1);
  private:
  const ::Servo& _internal_ear1() const;
  ::Servo* _internal_mutable_ear1();
  public:
  void unsafe_arena_set_allocated_ear1(
      ::Servo* ear1);
  ::Servo* unsafe_arena_release_ear1();
  // .Servo ear2 = 4;
  bool has_ear2() const;
  void clear_ear2() ;
  const ::Servo& ear2() const;
  PROTOBUF_NODISCARD ::Servo* release_ear2();
  ::Servo* mutable_ear2();
  void set_allocated_ear2(::Servo* ear2);
  private:
  const ::Servo& _internal_ear2() const;
  ::Servo* _internal_mutable_ear2();
  public:
  void unsafe_arena_set_allocated_ear2(
      ::Servo* ear2);
  ::Servo* unsafe_arena_release_ear2();
  // @@protoc_insertion_point(class_scope:Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::Motor* ma_;
    ::Motor* mb_;
    ::Servo* ear1_;
    ::Servo* ear2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rc_5fservice_2eproto;
};// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 8,
    kFrontFieldNumber = 1,
    kFront1FieldNumber = 2,
    kFloorFieldNumber = 3,
    kGyroscopeFieldNumber = 4,
    kLeftFieldNumber = 5,
    kRightFieldNumber = 6,
    kStatusFieldNumber = 7,
  };
  // string message = 8;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .DistanceSensor front = 1;
  bool has_front() const;
  void clear_front() ;
  const ::DistanceSensor& front() const;
  PROTOBUF_NODISCARD ::DistanceSensor* release_front();
  ::DistanceSensor* mutable_front();
  void set_allocated_front(::DistanceSensor* front);
  private:
  const ::DistanceSensor& _internal_front() const;
  ::DistanceSensor* _internal_mutable_front();
  public:
  void unsafe_arena_set_allocated_front(
      ::DistanceSensor* front);
  ::DistanceSensor* unsafe_arena_release_front();
  // .DistanceSensor front1 = 2;
  bool has_front1() const;
  void clear_front1() ;
  const ::DistanceSensor& front1() const;
  PROTOBUF_NODISCARD ::DistanceSensor* release_front1();
  ::DistanceSensor* mutable_front1();
  void set_allocated_front1(::DistanceSensor* front1);
  private:
  const ::DistanceSensor& _internal_front1() const;
  ::DistanceSensor* _internal_mutable_front1();
  public:
  void unsafe_arena_set_allocated_front1(
      ::DistanceSensor* front1);
  ::DistanceSensor* unsafe_arena_release_front1();
  // .DistanceSensor floor = 3;
  bool has_floor() const;
  void clear_floor() ;
  const ::DistanceSensor& floor() const;
  PROTOBUF_NODISCARD ::DistanceSensor* release_floor();
  ::DistanceSensor* mutable_floor();
  void set_allocated_floor(::DistanceSensor* floor);
  private:
  const ::DistanceSensor& _internal_floor() const;
  ::DistanceSensor* _internal_mutable_floor();
  public:
  void unsafe_arena_set_allocated_floor(
      ::DistanceSensor* floor);
  ::DistanceSensor* unsafe_arena_release_floor();
  // .Gyroscope gyroscope = 4;
  bool has_gyroscope() const;
  void clear_gyroscope() ;
  const ::Gyroscope& gyroscope() const;
  PROTOBUF_NODISCARD ::Gyroscope* release_gyroscope();
  ::Gyroscope* mutable_gyroscope();
  void set_allocated_gyroscope(::Gyroscope* gyroscope);
  private:
  const ::Gyroscope& _internal_gyroscope() const;
  ::Gyroscope* _internal_mutable_gyroscope();
  public:
  void unsafe_arena_set_allocated_gyroscope(
      ::Gyroscope* gyroscope);
  ::Gyroscope* unsafe_arena_release_gyroscope();
  // .AudioChunk left = 5;
  bool has_left() const;
  void clear_left() ;
  const ::AudioChunk& left() const;
  PROTOBUF_NODISCARD ::AudioChunk* release_left();
  ::AudioChunk* mutable_left();
  void set_allocated_left(::AudioChunk* left);
  private:
  const ::AudioChunk& _internal_left() const;
  ::AudioChunk* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::AudioChunk* left);
  ::AudioChunk* unsafe_arena_release_left();
  // .AudioChunk right = 6;
  bool has_right() const;
  void clear_right() ;
  const ::AudioChunk& right() const;
  PROTOBUF_NODISCARD ::AudioChunk* release_right();
  ::AudioChunk* mutable_right();
  void set_allocated_right(::AudioChunk* right);
  private:
  const ::AudioChunk& _internal_right() const;
  ::AudioChunk* _internal_mutable_right();
  public:
  void unsafe_arena_set_allocated_right(
      ::AudioChunk* right);
  ::AudioChunk* unsafe_arena_release_right();
  // int32 status = 7;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::DistanceSensor* front_;
    ::DistanceSensor* front1_;
    ::DistanceSensor* floor_;
    ::Gyroscope* gyroscope_;
    ::AudioChunk* left_;
    ::AudioChunk* right_;
    ::int32_t status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rc_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// _None

// -------------------------------------------------------------------

// Motor

// uint32 direction = 1;
inline void Motor::clear_direction() {
  _impl_.direction_ = 0u;
}
inline ::uint32_t Motor::direction() const {
  // @@protoc_insertion_point(field_get:Motor.direction)
  return _internal_direction();
}
inline void Motor::set_direction(::uint32_t value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Motor.direction)
}
inline ::uint32_t Motor::_internal_direction() const {
  return _impl_.direction_;
}
inline void Motor::_internal_set_direction(::uint32_t value) {
  ;
  _impl_.direction_ = value;
}

// uint32 speed = 2;
inline void Motor::clear_speed() {
  _impl_.speed_ = 0u;
}
inline ::uint32_t Motor::speed() const {
  // @@protoc_insertion_point(field_get:Motor.speed)
  return _internal_speed();
}
inline void Motor::set_speed(::uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Motor.speed)
}
inline ::uint32_t Motor::_internal_speed() const {
  return _impl_.speed_;
}
inline void Motor::_internal_set_speed(::uint32_t value) {
  ;
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// DistanceSensor

// double distance = 1;
inline void DistanceSensor::clear_distance() {
  _impl_.distance_ = 0;
}
inline double DistanceSensor::distance() const {
  // @@protoc_insertion_point(field_get:DistanceSensor.distance)
  return _internal_distance();
}
inline void DistanceSensor::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:DistanceSensor.distance)
}
inline double DistanceSensor::_internal_distance() const {
  return _impl_.distance_;
}
inline void DistanceSensor::_internal_set_distance(double value) {
  ;
  _impl_.distance_ = value;
}

// -------------------------------------------------------------------

// Gyroscope

// repeated double acceleration = 3;
inline int Gyroscope::_internal_acceleration_size() const {
  return _impl_.acceleration_.size();
}
inline int Gyroscope::acceleration_size() const {
  return _internal_acceleration_size();
}
inline void Gyroscope::clear_acceleration() {
  _internal_mutable_acceleration()->Clear();
}
inline double Gyroscope::acceleration(int index) const {
  // @@protoc_insertion_point(field_get:Gyroscope.acceleration)
  return _internal_acceleration(index);
}
inline void Gyroscope::set_acceleration(int index, double value) {
  _internal_mutable_acceleration()->Set(index, value);
  // @@protoc_insertion_point(field_set:Gyroscope.acceleration)
}
inline void Gyroscope::add_acceleration(double value) {
  _internal_add_acceleration(value);
  // @@protoc_insertion_point(field_add:Gyroscope.acceleration)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& Gyroscope::acceleration() const {
  // @@protoc_insertion_point(field_list:Gyroscope.acceleration)
  return _internal_acceleration();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* Gyroscope::mutable_acceleration() {
  // @@protoc_insertion_point(field_mutable_list:Gyroscope.acceleration)
  return _internal_mutable_acceleration();
}

inline double Gyroscope::_internal_acceleration(int index) const {
  return _internal_acceleration().Get(index);
}
inline void Gyroscope::_internal_add_acceleration(double value) {
  _internal_mutable_acceleration()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& Gyroscope::_internal_acceleration() const {
  return _impl_.acceleration_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* Gyroscope::_internal_mutable_acceleration() {
  return &_impl_.acceleration_;
}

// repeated double gyroscope = 6;
inline int Gyroscope::_internal_gyroscope_size() const {
  return _impl_.gyroscope_.size();
}
inline int Gyroscope::gyroscope_size() const {
  return _internal_gyroscope_size();
}
inline void Gyroscope::clear_gyroscope() {
  _internal_mutable_gyroscope()->Clear();
}
inline double Gyroscope::gyroscope(int index) const {
  // @@protoc_insertion_point(field_get:Gyroscope.gyroscope)
  return _internal_gyroscope(index);
}
inline void Gyroscope::set_gyroscope(int index, double value) {
  _internal_mutable_gyroscope()->Set(index, value);
  // @@protoc_insertion_point(field_set:Gyroscope.gyroscope)
}
inline void Gyroscope::add_gyroscope(double value) {
  _internal_add_gyroscope(value);
  // @@protoc_insertion_point(field_add:Gyroscope.gyroscope)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& Gyroscope::gyroscope() const {
  // @@protoc_insertion_point(field_list:Gyroscope.gyroscope)
  return _internal_gyroscope();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* Gyroscope::mutable_gyroscope() {
  // @@protoc_insertion_point(field_mutable_list:Gyroscope.gyroscope)
  return _internal_mutable_gyroscope();
}

inline double Gyroscope::_internal_gyroscope(int index) const {
  return _internal_gyroscope().Get(index);
}
inline void Gyroscope::_internal_add_gyroscope(double value) {
  _internal_mutable_gyroscope()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>& Gyroscope::_internal_gyroscope() const {
  return _impl_.gyroscope_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<double>* Gyroscope::_internal_mutable_gyroscope() {
  return &_impl_.gyroscope_;
}

// int32 accel_range = 7;
inline void Gyroscope::clear_accel_range() {
  _impl_.accel_range_ = 0;
}
inline ::int32_t Gyroscope::accel_range() const {
  // @@protoc_insertion_point(field_get:Gyroscope.accel_range)
  return _internal_accel_range();
}
inline void Gyroscope::set_accel_range(::int32_t value) {
  _internal_set_accel_range(value);
  // @@protoc_insertion_point(field_set:Gyroscope.accel_range)
}
inline ::int32_t Gyroscope::_internal_accel_range() const {
  return _impl_.accel_range_;
}
inline void Gyroscope::_internal_set_accel_range(::int32_t value) {
  ;
  _impl_.accel_range_ = value;
}

// int32 gyro_range = 8;
inline void Gyroscope::clear_gyro_range() {
  _impl_.gyro_range_ = 0;
}
inline ::int32_t Gyroscope::gyro_range() const {
  // @@protoc_insertion_point(field_get:Gyroscope.gyro_range)
  return _internal_gyro_range();
}
inline void Gyroscope::set_gyro_range(::int32_t value) {
  _internal_set_gyro_range(value);
  // @@protoc_insertion_point(field_set:Gyroscope.gyro_range)
}
inline ::int32_t Gyroscope::_internal_gyro_range() const {
  return _impl_.gyro_range_;
}
inline void Gyroscope::_internal_set_gyro_range(::int32_t value) {
  ;
  _impl_.gyro_range_ = value;
}

// -------------------------------------------------------------------

// Servo

// uint32 angle = 1;
inline void Servo::clear_angle() {
  _impl_.angle_ = 0u;
}
inline ::uint32_t Servo::angle() const {
  // @@protoc_insertion_point(field_get:Servo.angle)
  return _internal_angle();
}
inline void Servo::set_angle(::uint32_t value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:Servo.angle)
}
inline ::uint32_t Servo::_internal_angle() const {
  return _impl_.angle_;
}
inline void Servo::_internal_set_angle(::uint32_t value) {
  ;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// AudioChunk

// repeated int32 data = 32000;
inline int AudioChunk::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int AudioChunk::data_size() const {
  return _internal_data_size();
}
inline void AudioChunk::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::int32_t AudioChunk::data(int index) const {
  // @@protoc_insertion_point(field_get:AudioChunk.data)
  return _internal_data(index);
}
inline void AudioChunk::set_data(int index, ::int32_t value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:AudioChunk.data)
}
inline void AudioChunk::add_data(::int32_t value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:AudioChunk.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& AudioChunk::data() const {
  // @@protoc_insertion_point(field_list:AudioChunk.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* AudioChunk::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:AudioChunk.data)
  return _internal_mutable_data();
}

inline ::int32_t AudioChunk::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline void AudioChunk::_internal_add_data(::int32_t value) {
  _internal_mutable_data()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& AudioChunk::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* AudioChunk::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// Command

// .Motor mA = 1;
inline bool Command::has_ma() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ma_ != nullptr);
  return value;
}
inline void Command::clear_ma() {
  if (_impl_.ma_ != nullptr) _impl_.ma_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Motor& Command::_internal_ma() const {
  const ::Motor* p = _impl_.ma_;
  return p != nullptr ? *p : reinterpret_cast<const ::Motor&>(
      ::_Motor_default_instance_);
}
inline const ::Motor& Command::ma() const {
  // @@protoc_insertion_point(field_get:Command.mA)
  return _internal_ma();
}
inline void Command::unsafe_arena_set_allocated_ma(
    ::Motor* ma) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ma_);
  }
  _impl_.ma_ = ma;
  if (ma) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.mA)
}
inline ::Motor* Command::release_ma() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Motor* temp = _impl_.ma_;
  _impl_.ma_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Motor* Command::unsafe_arena_release_ma() {
  // @@protoc_insertion_point(field_release:Command.mA)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Motor* temp = _impl_.ma_;
  _impl_.ma_ = nullptr;
  return temp;
}
inline ::Motor* Command::_internal_mutable_ma() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ma_ == nullptr) {
    auto* p = CreateMaybeMessage<::Motor>(GetArenaForAllocation());
    _impl_.ma_ = p;
  }
  return _impl_.ma_;
}
inline ::Motor* Command::mutable_ma() {
  ::Motor* _msg = _internal_mutable_ma();
  // @@protoc_insertion_point(field_mutable:Command.mA)
  return _msg;
}
inline void Command::set_allocated_ma(::Motor* ma) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ma_;
  }
  if (ma) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ma);
    if (message_arena != submessage_arena) {
      ma = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ma, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ma_ = ma;
  // @@protoc_insertion_point(field_set_allocated:Command.mA)
}

// .Motor mB = 2;
inline bool Command::has_mb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mb_ != nullptr);
  return value;
}
inline void Command::clear_mb() {
  if (_impl_.mb_ != nullptr) _impl_.mb_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::Motor& Command::_internal_mb() const {
  const ::Motor* p = _impl_.mb_;
  return p != nullptr ? *p : reinterpret_cast<const ::Motor&>(
      ::_Motor_default_instance_);
}
inline const ::Motor& Command::mb() const {
  // @@protoc_insertion_point(field_get:Command.mB)
  return _internal_mb();
}
inline void Command::unsafe_arena_set_allocated_mb(
    ::Motor* mb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mb_);
  }
  _impl_.mb_ = mb;
  if (mb) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.mB)
}
inline ::Motor* Command::release_mb() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Motor* temp = _impl_.mb_;
  _impl_.mb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Motor* Command::unsafe_arena_release_mb() {
  // @@protoc_insertion_point(field_release:Command.mB)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Motor* temp = _impl_.mb_;
  _impl_.mb_ = nullptr;
  return temp;
}
inline ::Motor* Command::_internal_mutable_mb() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.mb_ == nullptr) {
    auto* p = CreateMaybeMessage<::Motor>(GetArenaForAllocation());
    _impl_.mb_ = p;
  }
  return _impl_.mb_;
}
inline ::Motor* Command::mutable_mb() {
  ::Motor* _msg = _internal_mutable_mb();
  // @@protoc_insertion_point(field_mutable:Command.mB)
  return _msg;
}
inline void Command::set_allocated_mb(::Motor* mb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mb_;
  }
  if (mb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mb);
    if (message_arena != submessage_arena) {
      mb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mb, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mb_ = mb;
  // @@protoc_insertion_point(field_set_allocated:Command.mB)
}

// .Servo ear1 = 3;
inline bool Command::has_ear1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ear1_ != nullptr);
  return value;
}
inline void Command::clear_ear1() {
  if (_impl_.ear1_ != nullptr) _impl_.ear1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::Servo& Command::_internal_ear1() const {
  const ::Servo* p = _impl_.ear1_;
  return p != nullptr ? *p : reinterpret_cast<const ::Servo&>(
      ::_Servo_default_instance_);
}
inline const ::Servo& Command::ear1() const {
  // @@protoc_insertion_point(field_get:Command.ear1)
  return _internal_ear1();
}
inline void Command::unsafe_arena_set_allocated_ear1(
    ::Servo* ear1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ear1_);
  }
  _impl_.ear1_ = ear1;
  if (ear1) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.ear1)
}
inline ::Servo* Command::release_ear1() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Servo* temp = _impl_.ear1_;
  _impl_.ear1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Servo* Command::unsafe_arena_release_ear1() {
  // @@protoc_insertion_point(field_release:Command.ear1)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::Servo* temp = _impl_.ear1_;
  _impl_.ear1_ = nullptr;
  return temp;
}
inline ::Servo* Command::_internal_mutable_ear1() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ear1_ == nullptr) {
    auto* p = CreateMaybeMessage<::Servo>(GetArenaForAllocation());
    _impl_.ear1_ = p;
  }
  return _impl_.ear1_;
}
inline ::Servo* Command::mutable_ear1() {
  ::Servo* _msg = _internal_mutable_ear1();
  // @@protoc_insertion_point(field_mutable:Command.ear1)
  return _msg;
}
inline void Command::set_allocated_ear1(::Servo* ear1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ear1_;
  }
  if (ear1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ear1);
    if (message_arena != submessage_arena) {
      ear1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ear1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ear1_ = ear1;
  // @@protoc_insertion_point(field_set_allocated:Command.ear1)
}

// .Servo ear2 = 4;
inline bool Command::has_ear2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ear2_ != nullptr);
  return value;
}
inline void Command::clear_ear2() {
  if (_impl_.ear2_ != nullptr) _impl_.ear2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::Servo& Command::_internal_ear2() const {
  const ::Servo* p = _impl_.ear2_;
  return p != nullptr ? *p : reinterpret_cast<const ::Servo&>(
      ::_Servo_default_instance_);
}
inline const ::Servo& Command::ear2() const {
  // @@protoc_insertion_point(field_get:Command.ear2)
  return _internal_ear2();
}
inline void Command::unsafe_arena_set_allocated_ear2(
    ::Servo* ear2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ear2_);
  }
  _impl_.ear2_ = ear2;
  if (ear2) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.ear2)
}
inline ::Servo* Command::release_ear2() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Servo* temp = _impl_.ear2_;
  _impl_.ear2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Servo* Command::unsafe_arena_release_ear2() {
  // @@protoc_insertion_point(field_release:Command.ear2)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Servo* temp = _impl_.ear2_;
  _impl_.ear2_ = nullptr;
  return temp;
}
inline ::Servo* Command::_internal_mutable_ear2() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.ear2_ == nullptr) {
    auto* p = CreateMaybeMessage<::Servo>(GetArenaForAllocation());
    _impl_.ear2_ = p;
  }
  return _impl_.ear2_;
}
inline ::Servo* Command::mutable_ear2() {
  ::Servo* _msg = _internal_mutable_ear2();
  // @@protoc_insertion_point(field_mutable:Command.ear2)
  return _msg;
}
inline void Command::set_allocated_ear2(::Servo* ear2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ear2_;
  }
  if (ear2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ear2);
    if (message_arena != submessage_arena) {
      ear2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ear2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ear2_ = ear2;
  // @@protoc_insertion_point(field_set_allocated:Command.ear2)
}

// -------------------------------------------------------------------

// Message

// .DistanceSensor front = 1;
inline bool Message::has_front() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.front_ != nullptr);
  return value;
}
inline void Message::clear_front() {
  if (_impl_.front_ != nullptr) _impl_.front_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DistanceSensor& Message::_internal_front() const {
  const ::DistanceSensor* p = _impl_.front_;
  return p != nullptr ? *p : reinterpret_cast<const ::DistanceSensor&>(
      ::_DistanceSensor_default_instance_);
}
inline const ::DistanceSensor& Message::front() const {
  // @@protoc_insertion_point(field_get:Message.front)
  return _internal_front();
}
inline void Message::unsafe_arena_set_allocated_front(
    ::DistanceSensor* front) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.front_);
  }
  _impl_.front_ = front;
  if (front) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.front)
}
inline ::DistanceSensor* Message::release_front() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DistanceSensor* temp = _impl_.front_;
  _impl_.front_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DistanceSensor* Message::unsafe_arena_release_front() {
  // @@protoc_insertion_point(field_release:Message.front)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DistanceSensor* temp = _impl_.front_;
  _impl_.front_ = nullptr;
  return temp;
}
inline ::DistanceSensor* Message::_internal_mutable_front() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.front_ == nullptr) {
    auto* p = CreateMaybeMessage<::DistanceSensor>(GetArenaForAllocation());
    _impl_.front_ = p;
  }
  return _impl_.front_;
}
inline ::DistanceSensor* Message::mutable_front() {
  ::DistanceSensor* _msg = _internal_mutable_front();
  // @@protoc_insertion_point(field_mutable:Message.front)
  return _msg;
}
inline void Message::set_allocated_front(::DistanceSensor* front) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.front_;
  }
  if (front) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(front);
    if (message_arena != submessage_arena) {
      front = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.front_ = front;
  // @@protoc_insertion_point(field_set_allocated:Message.front)
}

// .DistanceSensor front1 = 2;
inline bool Message::has_front1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.front1_ != nullptr);
  return value;
}
inline void Message::clear_front1() {
  if (_impl_.front1_ != nullptr) _impl_.front1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DistanceSensor& Message::_internal_front1() const {
  const ::DistanceSensor* p = _impl_.front1_;
  return p != nullptr ? *p : reinterpret_cast<const ::DistanceSensor&>(
      ::_DistanceSensor_default_instance_);
}
inline const ::DistanceSensor& Message::front1() const {
  // @@protoc_insertion_point(field_get:Message.front1)
  return _internal_front1();
}
inline void Message::unsafe_arena_set_allocated_front1(
    ::DistanceSensor* front1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.front1_);
  }
  _impl_.front1_ = front1;
  if (front1) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.front1)
}
inline ::DistanceSensor* Message::release_front1() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DistanceSensor* temp = _impl_.front1_;
  _impl_.front1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DistanceSensor* Message::unsafe_arena_release_front1() {
  // @@protoc_insertion_point(field_release:Message.front1)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DistanceSensor* temp = _impl_.front1_;
  _impl_.front1_ = nullptr;
  return temp;
}
inline ::DistanceSensor* Message::_internal_mutable_front1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.front1_ == nullptr) {
    auto* p = CreateMaybeMessage<::DistanceSensor>(GetArenaForAllocation());
    _impl_.front1_ = p;
  }
  return _impl_.front1_;
}
inline ::DistanceSensor* Message::mutable_front1() {
  ::DistanceSensor* _msg = _internal_mutable_front1();
  // @@protoc_insertion_point(field_mutable:Message.front1)
  return _msg;
}
inline void Message::set_allocated_front1(::DistanceSensor* front1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.front1_;
  }
  if (front1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(front1);
    if (message_arena != submessage_arena) {
      front1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.front1_ = front1;
  // @@protoc_insertion_point(field_set_allocated:Message.front1)
}

// .DistanceSensor floor = 3;
inline bool Message::has_floor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.floor_ != nullptr);
  return value;
}
inline void Message::clear_floor() {
  if (_impl_.floor_ != nullptr) _impl_.floor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::DistanceSensor& Message::_internal_floor() const {
  const ::DistanceSensor* p = _impl_.floor_;
  return p != nullptr ? *p : reinterpret_cast<const ::DistanceSensor&>(
      ::_DistanceSensor_default_instance_);
}
inline const ::DistanceSensor& Message::floor() const {
  // @@protoc_insertion_point(field_get:Message.floor)
  return _internal_floor();
}
inline void Message::unsafe_arena_set_allocated_floor(
    ::DistanceSensor* floor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.floor_);
  }
  _impl_.floor_ = floor;
  if (floor) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.floor)
}
inline ::DistanceSensor* Message::release_floor() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DistanceSensor* temp = _impl_.floor_;
  _impl_.floor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DistanceSensor* Message::unsafe_arena_release_floor() {
  // @@protoc_insertion_point(field_release:Message.floor)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DistanceSensor* temp = _impl_.floor_;
  _impl_.floor_ = nullptr;
  return temp;
}
inline ::DistanceSensor* Message::_internal_mutable_floor() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.floor_ == nullptr) {
    auto* p = CreateMaybeMessage<::DistanceSensor>(GetArenaForAllocation());
    _impl_.floor_ = p;
  }
  return _impl_.floor_;
}
inline ::DistanceSensor* Message::mutable_floor() {
  ::DistanceSensor* _msg = _internal_mutable_floor();
  // @@protoc_insertion_point(field_mutable:Message.floor)
  return _msg;
}
inline void Message::set_allocated_floor(::DistanceSensor* floor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.floor_;
  }
  if (floor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(floor);
    if (message_arena != submessage_arena) {
      floor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, floor, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.floor_ = floor;
  // @@protoc_insertion_point(field_set_allocated:Message.floor)
}

// .Gyroscope gyroscope = 4;
inline bool Message::has_gyroscope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gyroscope_ != nullptr);
  return value;
}
inline void Message::clear_gyroscope() {
  if (_impl_.gyroscope_ != nullptr) _impl_.gyroscope_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::Gyroscope& Message::_internal_gyroscope() const {
  const ::Gyroscope* p = _impl_.gyroscope_;
  return p != nullptr ? *p : reinterpret_cast<const ::Gyroscope&>(
      ::_Gyroscope_default_instance_);
}
inline const ::Gyroscope& Message::gyroscope() const {
  // @@protoc_insertion_point(field_get:Message.gyroscope)
  return _internal_gyroscope();
}
inline void Message::unsafe_arena_set_allocated_gyroscope(
    ::Gyroscope* gyroscope) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gyroscope_);
  }
  _impl_.gyroscope_ = gyroscope;
  if (gyroscope) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.gyroscope)
}
inline ::Gyroscope* Message::release_gyroscope() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Gyroscope* temp = _impl_.gyroscope_;
  _impl_.gyroscope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Gyroscope* Message::unsafe_arena_release_gyroscope() {
  // @@protoc_insertion_point(field_release:Message.gyroscope)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::Gyroscope* temp = _impl_.gyroscope_;
  _impl_.gyroscope_ = nullptr;
  return temp;
}
inline ::Gyroscope* Message::_internal_mutable_gyroscope() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.gyroscope_ == nullptr) {
    auto* p = CreateMaybeMessage<::Gyroscope>(GetArenaForAllocation());
    _impl_.gyroscope_ = p;
  }
  return _impl_.gyroscope_;
}
inline ::Gyroscope* Message::mutable_gyroscope() {
  ::Gyroscope* _msg = _internal_mutable_gyroscope();
  // @@protoc_insertion_point(field_mutable:Message.gyroscope)
  return _msg;
}
inline void Message::set_allocated_gyroscope(::Gyroscope* gyroscope) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gyroscope_;
  }
  if (gyroscope) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gyroscope);
    if (message_arena != submessage_arena) {
      gyroscope = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gyroscope, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.gyroscope_ = gyroscope;
  // @@protoc_insertion_point(field_set_allocated:Message.gyroscope)
}

// .AudioChunk left = 5;
inline bool Message::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void Message::clear_left() {
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::AudioChunk& Message::_internal_left() const {
  const ::AudioChunk* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::AudioChunk&>(
      ::_AudioChunk_default_instance_);
}
inline const ::AudioChunk& Message::left() const {
  // @@protoc_insertion_point(field_get:Message.left)
  return _internal_left();
}
inline void Message::unsafe_arena_set_allocated_left(
    ::AudioChunk* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = left;
  if (left) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.left)
}
inline ::AudioChunk* Message::release_left() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::AudioChunk* temp = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AudioChunk* Message::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:Message.left)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::AudioChunk* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::AudioChunk* Message::_internal_mutable_left() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::AudioChunk>(GetArenaForAllocation());
    _impl_.left_ = p;
  }
  return _impl_.left_;
}
inline ::AudioChunk* Message::mutable_left() {
  ::AudioChunk* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:Message.left)
  return _msg;
}
inline void Message::set_allocated_left(::AudioChunk* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.left_ = left;
  // @@protoc_insertion_point(field_set_allocated:Message.left)
}

// .AudioChunk right = 6;
inline bool Message::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void Message::clear_right() {
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::AudioChunk& Message::_internal_right() const {
  const ::AudioChunk* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::AudioChunk&>(
      ::_AudioChunk_default_instance_);
}
inline const ::AudioChunk& Message::right() const {
  // @@protoc_insertion_point(field_get:Message.right)
  return _internal_right();
}
inline void Message::unsafe_arena_set_allocated_right(
    ::AudioChunk* right) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = right;
  if (right) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.right)
}
inline ::AudioChunk* Message::release_right() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::AudioChunk* temp = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AudioChunk* Message::unsafe_arena_release_right() {
  // @@protoc_insertion_point(field_release:Message.right)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::AudioChunk* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::AudioChunk* Message::_internal_mutable_right() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::AudioChunk>(GetArenaForAllocation());
    _impl_.right_ = p;
  }
  return _impl_.right_;
}
inline ::AudioChunk* Message::mutable_right() {
  ::AudioChunk* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:Message.right)
  return _msg;
}
inline void Message::set_allocated_right(::AudioChunk* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right);
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.right_ = right;
  // @@protoc_insertion_point(field_set_allocated:Message.right)
}

// int32 status = 7;
inline void Message::clear_status() {
  _impl_.status_ = 0;
}
inline ::int32_t Message::status() const {
  // @@protoc_insertion_point(field_get:Message.status)
  return _internal_status();
}
inline void Message::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Message.status)
}
inline ::int32_t Message::_internal_status() const {
  return _impl_.status_;
}
inline void Message::_internal_set_status(::int32_t value) {
  ;
  _impl_.status_ = value;
}

// string message = 8;
inline void Message::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Message::message() const {
  // @@protoc_insertion_point(field_get:Message.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Message::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.message)
}
inline std::string* Message::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Message.message)
  return _s;
}
inline const std::string& Message::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Message::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* Message::release_message() {
  // @@protoc_insertion_point(field_release:Message.message)
  return _impl_.message_.Release();
}
inline void Message::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_rc_5fservice_2eproto_2epb_2eh
